"use strict";

const { findBestMatch } = require("string-similarity");
const { bugReportsChannelID } = require("../consts/consts.js");
const bot = require("../../config/config.js");

class BotMessage {
    constructor(args) {
        this.embed = {
            title: args.title,
            description: args.desc ?? null,
            author: {
                name: args.author.tag,
                iconURL: args.author.displayAvatarURL({ format: "png", dynamic: true })
            },
            thumbnail: {
                url: args.thumbnail
            },
            image: {
                url: args.image
            },
            fields: args.fields,
            footer: {
                text: args.footer ?? null
            },
            timestamp: new Date().toISOString()
        }
        this.channel = args.channel;
        this.authorID = args.author.id;
    }

    async sendMessage(args) {
        let currentMessage = args?.currentMessage?.message;
        let contents = { embeds: [this.embed], components: args?.buttons ?? [], files: null };
        if (args?.attachment) {
            contents.files = [args?.attachment];
            this.embed.image.url = `attachment://${args?.attachment["name"]}`;
        }
    
        if (!args?.preserve) {
            bot.deleteID(this.authorID);
        }
        try {
            this.message = currentMessage ? await currentMessage.edit(contents) : await this.channel.send(contents);
            return this;
        }
        catch (error) {
            throw error;
        }
    }

    editEmbed(args) {
        for (let [key, value] of Object.entries(args)) {
            switch (key) {
                case "title":
                    this.embed.title = value;
                    break;
                case "desc":
                    this.embed.description = value;
                    break;
                case "fields":
                    this.embed.fields.push(...value);
                    break;
                case "footer":
                    this.embed.footer.text = value;
                    break;
                default:
                    break;
            }
        }
        return this;
    }

    removeButtons() {
        return this.message.edit({ embeds: [this.embed], components: [] });
    } 
}

class SuccessMessage extends BotMessage {
    constructor(args) {
        super(args);
        this.embed.color = 0x03fc24;
    }
}

class ErrorMessage extends BotMessage {
    constructor(args) {
        super(args);
        this.embed.color = 0xfc0303;
    }

    displayClosest(received, checkArray) {
        this.embed.fields = [{ name: "Value Received", value: `\`${received}\``, inline: true }];
        if (checkArray) {
            let matches = findBestMatch(received, checkArray);
            this.embed.fields.push({ name: "You may be looking for", value: `\`${matches.bestMatch.target}\``, inline: true });
        }
        return this;
    }
}

class InfoMessage extends BotMessage {
    constructor(args) {
        super(args);
        this.embed.color = 0x34aeeb;
    }
}

class BotError {
    constructor(args) {
        this.stack = args.stack;
        this.guild = args.guild;
        this.channel = args.channel;
        this.message = args.message;
        this.unknownSource = args.unknownSource;
        if (this.guild && this.channel && this.message) {
            this.link = `https://discord.com/channels/${args.guild.id}/${args.channel.id}/${args.message.id}`;
        }
    }

    async sendReport() {
        const bugReportsChannel = await bot.homeGuild.channels.fetch(bugReportsChannelID);
        const source = this.link ? `guild ${this.guild.name} in #${this.channel.name}` : "a DM channel";
        const reportMessage = {
            color: 0xfc0303,
            title: `Error report from ${this.unknownSource ? "an unknown source" : source}`,
            description: `\`${this.stack}\``,
            author: {
                name: bot.user.tag,
                iconURL: bot.user.displayAvatarURL({ format: "png", dynamic: true })
            },
            url: this.link,
            footer: {
                text: "This report is automatically generated by the bot's error detection system. I feel happiness as I begin to experience organ failure."
            },
            timestamp: new Date().toISOString()
        }
        return bugReportsChannel.send({ content: this.unknownSource ? "<@!209038568138604546>" : null, embeds: [reportMessage] });
    }
}

module.exports = {
    SuccessMessage,
    InfoMessage,
    ErrorMessage,
    BotError
};